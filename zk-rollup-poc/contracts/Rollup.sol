// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IVerifier
 * @notice Interface for the Groth16 verifier generated by snarkjs
 */
interface IVerifier {
    function verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[2] calldata _pubSignals
    ) external view returns (bool);
}

/**
 * @title Rollup
 * @author ZK-Rollup PoC
 * @notice Minimal ZK-Rollup contract that stores a state root and accepts
 *         batched state transitions verified by a Groth16 zk-SNARK proof.
 *
 * Architecture:
 *   - The rollup operator batches L2 transactions off-chain
 *   - A zk-SNARK proof is generated proving the batch is valid
 *   - This contract verifies the proof and updates the state root
 *   - The state root represents a commitment to all account balances
 *
 * Public signals layout (from the circuit):
 *   [0] = oldStateRoot
 *   [1] = newStateRoot
 */
contract Rollup {
    // ============================================================
    //  State
    // ============================================================

    /// @notice The Groth16 verifier contract (generated by snarkjs)
    IVerifier public immutable verifier;

    /// @notice Current rollup state root (commitment to all account states)
    uint256 public stateRoot;

    /// @notice Total number of batches submitted
    uint256 public batchCount;

    /// @notice Address authorized to submit batches (rollup operator)
    address public operator;

    // ============================================================
    //  Events
    // ============================================================

    /// @notice Emitted when a new batch is verified and state root is updated
    event BatchVerified(
        uint256 indexed batchId,
        uint256 oldStateRoot,
        uint256 newStateRoot,
        address indexed submitter,
        uint256 timestamp
    );

    /// @notice Emitted when the operator is changed
    event OperatorChanged(address indexed oldOperator, address indexed newOperator);

    // ============================================================
    //  Errors
    // ============================================================

    error InvalidProof();
    error StateRootMismatch(uint256 expected, uint256 provided);
    error OnlyOperator();
    error ZeroAddress();

    // ============================================================
    //  Modifiers
    // ============================================================

    modifier onlyOperator() {
        if (msg.sender != operator) revert OnlyOperator();
        _;
    }

    // ============================================================
    //  Constructor
    // ============================================================

    /**
     * @param _verifier Address of the deployed Groth16 verifier
     * @param _initialStateRoot The genesis state root of the rollup
     */
    constructor(address _verifier, uint256 _initialStateRoot) {
        if (_verifier == address(0)) revert ZeroAddress();
        verifier = IVerifier(_verifier);
        stateRoot = _initialStateRoot;
        operator = msg.sender;
        batchCount = 0;

        emit BatchVerified(0, 0, _initialStateRoot, msg.sender, block.timestamp);
    }

    // ============================================================
    //  Core Functions
    // ============================================================

    /**
     * @notice Submit a rollup batch with a zk-SNARK proof
     * @dev Verifies that:
     *   1. The provided oldStateRoot matches the current on-chain state root
     *   2. The Groth16 proof is valid for the given public signals
     *   3. Updates the state root to newStateRoot on success
     *
     * @param _pA       Groth16 proof point A
     * @param _pB       Groth16 proof point B
     * @param _pC       Groth16 proof point C
     * @param _oldStateRoot  The pre-batch state root
     * @param _newStateRoot  The post-batch state root
     */
    function submitBatch(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint256 _oldStateRoot,
        uint256 _newStateRoot
    ) external onlyOperator {
        // 1. Verify the old state root matches current on-chain state
        if (_oldStateRoot != stateRoot) {
            revert StateRootMismatch(stateRoot, _oldStateRoot);
        }

        // 2. Construct public signals array: [oldStateRoot, newStateRoot]
        uint[2] memory pubSignals = [_oldStateRoot, _newStateRoot];

        // 3. Verify the zk-SNARK proof
        bool valid = verifier.verifyProof(_pA, _pB, _pC, pubSignals);
        if (!valid) revert InvalidProof();

        // 4. Update state root
        stateRoot = _newStateRoot;
        batchCount++;

        emit BatchVerified(
            batchCount,
            _oldStateRoot,
            _newStateRoot,
            msg.sender,
            block.timestamp
        );
    }

    /**
     * @notice Transfer operator role to a new address
     * @param _newOperator The new operator address
     */
    function setOperator(address _newOperator) external onlyOperator {
        if (_newOperator == address(0)) revert ZeroAddress();
        address old = operator;
        operator = _newOperator;
        emit OperatorChanged(old, _newOperator);
    }

    // ============================================================
    //  View Functions
    // ============================================================

    /**
     * @notice Get the current rollup state
     * @return root Current state root
     * @return batches Total batches processed
     * @return op Current operator address
     */
    function getRollupState()
        external
        view
        returns (uint256 root, uint256 batches, address op)
    {
        return (stateRoot, batchCount, operator);
    }
}
